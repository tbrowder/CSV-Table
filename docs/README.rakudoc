=begin pod

=head1 NAME

B<CSV::Table> - Provides routines for querying and modifying a CSV file with 
or without a header row.

=head1 SYNOPSIS

For example, using an MxN row/column matrix for data plus a header row
in a file with the first three lines being:

=begin code :lang<raku>
name, age, ...
John, 40,  ...
Sally, 38, ...
...
=end code

Handle the file with C<CSV::Table> in a Raku program:

=begin code :lang<raku>
use CSV::Table;
# with indexing from zero
my $t = CSV::Table.new: :csv($my-csv-file);
say $t.fields;       # OUTPUT: M   # zero if no header row
say $t.rows;         # OUTPUT: N-1 # N if no header row
say $t.cols;         # OUTPUT: M
say $t.field[0];     # OUTPUT: name # (Any) if no header row
say $t.cell[0][0];   # OUTPUT: John
=end code

There are multiple ways to query a data cell:

=item by row and column

=begin code :lang<raku>
say $t.cell[1][0]    # OUTPUT: Sally
say $t.rowcol(1, 0); # OUTPUT: Sally
say $t.rc(1, 0);     # OUTPUT: Sally
say $t.ij(1, 0);     # OUTPUT: Sally
=end code

=item by column and row

=begin code :lang<raku>
say $t.colrow(0, 1); # OUTPUT: Sally
say $t.cr(0, 1);     # OUTPUT: Sally
say $t.ji(0, 1);     # OUTPUT: Sally
=end code

You can change the value of any cell:

=begin code :lang<raku>
$t.cell[0][1] = 48;
$t.rowcol(0, 1, 50);
=end code

You can also change the names of fields, but, unless
you also change the corresponding field names in
the data hashes, you will most likely have problems.
It would be much easier to modify the original
CSV file.

You can choose to save the changed data (C<$t.save>),
any time, but you will be asked to confirm the save.

=head1 DESCRIPTION

B<CSV::Table> is a class enabling access to a CSV table's
contents. Tables with a header
row must have unique field names. 

By default,
text is 'normalized', that is, it is trimmed
of leading and trailing whitespace and multiple contiguous
interior whitespaces are collapsed into single ones.

Input files are read immediately, so very large files may
overwhelm system resources. 

It can handle the following which other CSV handlers may not:

=item With a header line
=item2 normalizing field names
=item2 data lines with fewer fields than a header (missing values assumed to be "")
=item2 data lines with more fields than its header (fatal, but reported)

Note header lines with any empty fields causes an exception. This is a valid
header line:

=begin code
field0, field1, field2
=end code

This header line is B<not> valid (notice the ending comma has no text following it):

=begin code
field0, field1, field2,
=end code

=item Without a header line
=item2 data lines are padded with empty fields to the maximum number of fields
found in the file

As simple as it is, it also has some uncommon features that are very useful:

=begin item
Comment lines are allowed

This feature, which is not usual in CSV parsers, is to ignore comment
lines interspersed between data lines (such lines may have leading whitespace).
The comment character is user-definable and its presence invalidates its
use as a field separator.
=end item

=begin item
There is a C<save> method which saves the current state of the CSV file 
(including comments) as well as saving a "raw" CSV file without the 
comments so the file can be used with conventional CSV handlers such as 
LibreOffice or Excel.
=end item

=begin item
Text normalization

Its results are to normalize text in a field, that is: leading and
trailing whitespace is trimmed and interior whitespace is collapsed to
one space between words.  This is the default behavior but can be
turned off if desired (C<normalize=False>).
In that event, data in all fields are still trimmed of leading and trailing
whitespace (unless C<trim=False>).
=end item

=begin item
Automatic determination of separator character

Unless the field separator is selected otherwise, the first line is 
searched for the most-used separator character from
this list: C<|>, C<;>, C<,> and C<\t>.  Other non-space characters may be used
but are probably not tested. File an issue if you want to add a
separator not currently specified.
=end item

=head2 Limitations

It cannot currently handle:

=item special characters
=item backslashes
=item binary data
=item duplicate field names in a header line

=head2 Constructor with default options

=begin code
my $t = CSV::Table.new: :$csv, 
                        :has-header=True,
                        :separator='auto', 
                        :normalize=True, 
                        :trim=True, 
                        :comment-char='#', 
                        :line-ending="\n"
                        ;
=end code

Following are the allowable values for the named arguments. The user
is cautioned that unspecified values are probably not tested. File an
issue if your value of choice is not specified and it can be added
and tested for.

=item C<:$separator>
=item2 auto [default]
=item2 comma (C<,>)
=item2 pipe (C<|>)
=item2 semicolon (C<;>)
=item2 tab (C<\t>)

=item C<:$normalize>
=item2 C<True> [default]
=item2 C<False>

=item C<:$trim>
=item2 C<True> [default]
=item2 C<False>

=item C<:$comment-char>
=item2 C<#> [default]
=item2 others, including multiple characters, are possible

=item C<:$has-header>
=item2 C<True> [default]
=item2 C<False>

=item C<:$line-ending>
=item2 C<"\n"> [default]
=item2 C<String>

=head2 Accessing the table

The following table shows how to access each cell in a table C<$t>
with a header row plus C<R> rows and C<C> columns of data.
(In matrix terminology it is an C<M x N> rectangular matrix with C<M> rows and C<N> columns.)

=begin table
$t.field[0] | ... | $t.field[C-1]
$t.cell[0][0] | ... | $t.cell[0][C-1]
...         | ... | ...
$t.cell[R-1][0] | ... | $t.cell[R-1][C-1]
=end table

The table's data cells can also be accessed by field name and row number:

=begin code
$t.col{$field-name}{$row-number}
=end code

=head1 AUTHOR

Tom Browder <tbrowder@acm.org>

=head1 COPYRIGHT AND LICENSE

Â© 2024 Tom Browder

This library is free software; you may redistribute it or modify it under the Artistic License 2.0.

=end pod
